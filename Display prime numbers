# Display all the prime numbers between 2 and 500
# Largest potential prime considered
MAX = 500

def display_primes_upto_500():
    # Each position in the Boolean list indicates
    # if the number of that position is not prime:
    # false means "Prime," and true means "composite."
    # Initially all numbers are prime until proven otherwise
    nonprimes = [False] * (MAX + 1) # Initialize to all False
    # First prime number is 2; 0 and 1 are not prime
    nonprimes[0] = nonprimes[1] = True

    # Start at the first prime number, 2.
    for i in range(2, MAX + 1):
        # See if it is prime
        if not nonprimes[i]:
            print(i, end=' ')
            # It is prime, so eliminate all of its
            # multiples that cannot be prime
            for j in range(2*i, MAX + 1, i):
                nonprimes[j] = True
    print() # Move cursor down to next line

# Count the number of prime numbers less than 
# 2 million and time how long it takes
# Compares the performance of two different algorithms.

from time import perf_counter
from math import sqrt

def count_primes(n):
    """ Generates all the prime numbers from 2 to n - 1. n - 1 is the largest potential
        prime considered. """
    
    start = perf_counter() # Record start time

    count = 0
    for val in range(2, n):
        root = round(sqrt(val)) + 1
        # Try all potential factors from 2 to the square root of n
        for trail_factor in range(2, root):
            if val % trail_factor == 0:  # Is it a factor?
                break                    # Found a factor
        else:
            count += 1                   # No factor found
    
    stop = perf_counter()   # Stop the clock
    print("Count = ", count, "Elapsed time: ", stop - start, "seconds")

def sieve(n):
    """ Generate all the prime numbers from 2 to n - 1. n - 1 is the largest potential 
    prime considered. Algorithm originally developed by Eratosthenes. """

    start = perf_counter() # Record start time 
    # each position in the boolean list indicates
    # if the number of that position is not prime:
    # false means "prime, " and true means "composite."
    # Initially all numbers are prime until proven otherwise
    nonprimes = n * [False] # Global list intialized to all false

    count = 0

    # First prime number is 2; 0 and 1 are not prime
    nonprimes[0] = nonprimes[1] = True

    # Start at the first prime number, 2.
    for i in range(2, n):
        # See if i is prime
        if not nonprimes[i]:
            count += 1
            # It is prime, so eliminate all of its
            # multiples that cannot be prime
            for j in range(2*i, n, i):
                nonprimes[j] = True
    # Print the elapsed time
    stop = perf_counter()
    print("Count = ", count, "Elapsed time: ", stop - start, "seconds")

if __name__ == "__main__":
    print("Primes up to 500: ")
    display_primes_upto_500()
    print("\nBenchmarking count methods up to 1000:")
    count_primes(1000)
    sieve(1000)
